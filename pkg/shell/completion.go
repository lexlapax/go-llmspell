// ABOUTME: Shell completion generation for various shells (bash, zsh, fish, powershell).
// ABOUTME: Provides completion scripts that can be sourced or installed for command-line tab completion.

package shell

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"
)

// Shell represents a supported shell type
type Shell string

const (
	// Bash shell
	Bash Shell = "bash"
	// Zsh shell
	Zsh Shell = "zsh"
	// Fish shell
	Fish Shell = "fish"
	// PowerShell
	PowerShell Shell = "powershell"
	// POSIX sh
	Sh Shell = "sh"
)

// CompletionGenerator generates shell completion scripts
type CompletionGenerator struct {
	ProgramName string
	Commands    []Command
	GlobalFlags []Flag
}

// Command represents a CLI command
type Command struct {
	Name        string
	Description string
	Subcommands []Command
	Flags       []Flag
}

// Flag represents a command flag
type Flag struct {
	Long        string
	Short       string
	Description string
	HasValue    bool
	Values      []string // For enum flags
}

// NewCompletionGenerator creates a new completion generator
func NewCompletionGenerator(programName string) *CompletionGenerator {
	return &CompletionGenerator{
		ProgramName: programName,
		Commands:    make([]Command, 0),
		GlobalFlags: make([]Flag, 0),
	}
}

// AddCommand adds a command to the generator
func (g *CompletionGenerator) AddCommand(cmd Command) {
	g.Commands = append(g.Commands, cmd)
}

// AddGlobalFlag adds a global flag
func (g *CompletionGenerator) AddGlobalFlag(flag Flag) {
	g.GlobalFlags = append(g.GlobalFlags, flag)
}

// Generate generates completion script for the specified shell
func (g *CompletionGenerator) Generate(shell Shell) (string, error) {
	switch shell {
	case Bash:
		return g.generateBash()
	case Zsh:
		return g.generateZsh()
	case Fish:
		return g.generateFish()
	case PowerShell:
		return g.generatePowerShell()
	case Sh:
		return g.generateSh()
	default:
		return "", fmt.Errorf("unsupported shell: %s", shell)
	}
}

// ParseShell parses a shell name string
func ParseShell(name string) (Shell, error) {
	switch strings.ToLower(name) {
	case "bash":
		return Bash, nil
	case "zsh":
		return Zsh, nil
	case "fish":
		return Fish, nil
	case "powershell", "pwsh":
		return PowerShell, nil
	case "sh":
		return Sh, nil
	default:
		return "", fmt.Errorf("unknown shell: %s", name)
	}
}

// GetSupportedShells returns a list of supported shells
func GetSupportedShells() []Shell {
	return []Shell{Bash, Zsh, Fish, PowerShell, Sh}
}

// generateBash generates Bash completion script
func (g *CompletionGenerator) generateBash() (string, error) {
	const bashTemplate = `#!/bin/bash
# {{ .ProgramName }} completion script for Bash
# Generated by llmspell

_{{ .ProgramName }}_complete() {
    local cur prev words cword
    _init_completion || return

    # Command hierarchy
    local commands=({{ range .Commands }}"{{ .Name }}" {{ end }})
    local global_flags=({{ range .GlobalFlags }}--{{ .Long }}{{ if .Short }} -{{ .Short }}{{ end }} {{ end }})

    # If we're completing the first argument, show commands
    if [[ ${cword} -eq 1 ]]; then
        COMPREPLY=( $(compgen -W "${commands[*]} ${global_flags[*]}" -- "${cur}") )
        return 0
    fi

    # Handle command-specific completion
    case "${words[1]}" in
        {{ range .Commands }}
        {{ .Name }})
            _{{ $.ProgramName }}_{{ .Name }}_complete
            return 0
            ;;
        {{ end }}
    esac

    # Default to files
    _filedir
}

{{ range .Commands }}
_{{ $.ProgramName }}_{{ .Name }}_complete() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local flags=({{ range .Flags }}--{{ .Long }}{{ if .Short }} -{{ .Short }}{{ end }} {{ end }})
    {{ if .Subcommands }}
    local subcommands=({{ range .Subcommands }}"{{ .Name }}" {{ end }})
    
    # Check if we should complete subcommands
    if [[ ${COMP_CWORD} -eq 2 ]]; then
        COMPREPLY=( $(compgen -W "${subcommands[*]} ${flags[*]}" -- "${cur}") )
        return 0
    fi
    {{ end }}
    
    case "${cur}" in
        -*)
            COMPREPLY=( $(compgen -W "${flags[*]}" -- "${cur}") )
            ;;
        *)
            _filedir
            ;;
    esac
}
{{ end }}

complete -F _{{ .ProgramName }}_complete {{ .ProgramName }}
`

	tmpl, err := template.New("bash").Parse(bashTemplate)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, g)
	if err != nil {
		return "", err
	}

	return buf.String(), nil
}

// generateZsh generates Zsh completion script
func (g *CompletionGenerator) generateZsh() (string, error) {
	const zshTemplate = `#compdef {{ .ProgramName }}
# {{ .ProgramName }} completion script for Zsh
# Generated by llmspell

_{{ .ProgramName }}() {
    local -a commands
    commands=(
        {{ range .Commands }}'{{ .Name }}:{{ .Description }}'
        {{ end }}
    )

    local -a global_flags
    global_flags=(
        {{ range .GlobalFlags }}'{{ if .Short }}-{{ .Short }}{{ end }}{{ if and .Short .Long }}[{{ end }}--{{ .Long }}{{ if and .Short .Long }}]{{ end }}:{{ .Description }}'
        {{ end }}
    )

    _arguments -C \
        "${global_flags[@]}" \
        '1: :->command' \
        '*:: :->args'

    case $state in
        command)
            _describe '{{ .ProgramName }} commands' commands
            ;;
        args)
            case $words[1] in
                {{ range .Commands }}
                {{ .Name }})
                    _{{ $.ProgramName }}_{{ .Name }}
                    ;;
                {{ end }}
            esac
            ;;
    esac
}

{{ range .Commands }}
_{{ $.ProgramName }}_{{ .Name }}() {
    local -a flags
    flags=(
        {{ range .Flags }}'{{ if .Short }}-{{ .Short }}{{ end }}{{ if and .Short .Long }}[{{ end }}--{{ .Long }}{{ if and .Short .Long }}]{{ end }}:{{ .Description }}{{ if .HasValue }}:{{ if .Values }}({{ range $i, $v := .Values }}{{ if $i }} {{ end }}{{ $v }}{{ end }}){{ else }}_files{{ end }}{{ end }}'
        {{ end }}
    )
    {{ if .Subcommands }}
    local -a subcommands
    subcommands=(
        {{ range .Subcommands }}'{{ .Name }}:{{ .Description }}'
        {{ end }}
    )
    
    _arguments -C \
        "${flags[@]}" \
        '1: :->subcommand' \
        '*:: :->args'
    
    case $state in
        subcommand)
            _describe '{{ .Name }} subcommands' subcommands
            ;;
    esac
    {{ else }}
    _arguments -s \
        "${flags[@]}" \
        '*:file:_files'
    {{ end }}
}
{{ end }}

_{{ .ProgramName }} "$@"
`

	tmpl, err := template.New("zsh").Parse(zshTemplate)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, g)
	if err != nil {
		return "", err
	}

	return buf.String(), nil
}

// generateFish generates Fish completion script
func (g *CompletionGenerator) generateFish() (string, error) {
	const fishTemplate = `# {{ .ProgramName }} completion script for Fish
# Generated by llmspell

# Disable file completion by default
complete -c {{ .ProgramName }} -f

# Global flags
{{ range .GlobalFlags }}complete -c {{ $.ProgramName }} -l {{ .Long }}{{ if .Short }} -s {{ .Short }}{{ end }} -d '{{ .Description }}'{{ if .Values }} -xa '{{ range $i, $v := .Values }}{{ if $i }} {{ end }}{{ $v }}{{ end }}'{{ end }}
{{ end }}

# Commands
{{ range .Commands }}complete -c {{ $.ProgramName }} -n '__fish_use_subcommand' -a {{ .Name }} -d '{{ .Description }}'
{{ end }}

# Command-specific completions
{{ range $cmd := .Commands }}
# {{ $cmd.Name }} command
{{ if $cmd.Subcommands }}{{ range $sub := $cmd.Subcommands }}complete -c {{ $.ProgramName }} -n '__fish_seen_subcommand_from {{ $cmd.Name }}; and not __fish_seen_subcommand_from {{ range $cmd.Subcommands }}{{ .Name }} {{ end }}' -a {{ $sub.Name }} -d '{{ $sub.Description }}'
{{ end }}{{ end }}
{{ range $flag := $cmd.Flags }}complete -c {{ $.ProgramName }} -n '__fish_seen_subcommand_from {{ $cmd.Name }}' -l {{ $flag.Long }}{{ if $flag.Short }} -s {{ $flag.Short }}{{ end }} -d '{{ $flag.Description }}'{{ if and $flag.HasValue (not $flag.Values) }} -r{{ end }}{{ if $flag.Values }} -xa '{{ range $i, $v := $flag.Values }}{{ if $i }} {{ end }}{{ $v }}{{ end }}'{{ end }}
{{ end }}
{{ end }}

# Enable file completion for specific commands
complete -c {{ .ProgramName }} -n '__fish_seen_subcommand_from run validate debug' -F
`

	tmpl, err := template.New("fish").Parse(fishTemplate)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, g)
	if err != nil {
		return "", err
	}

	return buf.String(), nil
}

// generatePowerShell generates PowerShell completion script
func (g *CompletionGenerator) generatePowerShell() (string, error) {
	const psTemplate = `# {{ .ProgramName }} completion script for PowerShell
# Generated by llmspell

Register-ArgumentCompleter -Native -CommandName {{ .ProgramName }} -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)
    
    $commands = @({{ range $i, $cmd := .Commands }}{{ if $i }}, {{ end }}'{{ $cmd.Name }}'{{ end }})
    $globalFlags = @({{ range $i, $flag := .GlobalFlags }}{{ if $i }}, {{ end }}'--{{ $flag.Long }}'{{ if $flag.Short }}, '-{{ $flag.Short }}'{{ end }}{{ end }})
    
    # Parse the command line
    $words = $commandAst.ToString() -split '\s+'
    
    # Determine context
    if ($words.Length -eq 1) {
        # Complete commands and global flags
        $commands + $globalFlags | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
            [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
        }
    } else {
        $command = $words[1]
        switch ($command) {
            {{ range .Commands }}
            '{{ .Name }}' {
                $flags = @({{ range .Flags }}'--{{ .Long }}'{{ if .Short }}, '-{{ .Short }}'{{ end }}{{ end }})
                {{ if .Subcommands }}
                $subcommands = @({{ range .Subcommands }}'{{ .Name }}'{{ end }})
                if ($words.Length -eq 2) {
                    $subcommands + $flags | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                        [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                    }
                } else {
                {{ end }}
                    $flags | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                        [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                    }
                {{ if .Subcommands }}}{{ end }}
            }
            {{ end }}
            default {
                # File completion
                Get-ChildItem -Path "./$wordToComplete*" | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_.Name, $_.Name, 'ParameterValue', $_.Name)
                }
            }
        }
    }
}
`

	tmpl, err := template.New("powershell").Parse(psTemplate)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, g)
	if err != nil {
		return "", err
	}

	return buf.String(), nil
}

// generateSh generates POSIX sh completion script
func (g *CompletionGenerator) generateSh() (string, error) {
	// POSIX sh doesn't have native completion, so we generate a simple helper
	const shTemplate = `#!/bin/sh
# {{ .ProgramName }} command reference for POSIX sh
# Generated by llmspell

# This shell doesn't support programmable completion.
# Here's a reference of available commands:

cat <<'EOF'
{{ .ProgramName }} - LLM spell runner

COMMANDS:
{{ range .Commands }}    {{ .Name }}{{ if .Description }} - {{ .Description }}{{ end }}
{{ end }}
GLOBAL FLAGS:
{{ range .GlobalFlags }}    --{{ .Long }}{{ if .Short }}, -{{ .Short }}{{ end }}{{ if .Description }} - {{ .Description }}{{ end }}
{{ end }}
For command-specific help, use:
    {{ .ProgramName }} <command> --help

To enable completion in supported shells, run:
    {{ .ProgramName }} completion <shell>

Supported shells: bash, zsh, fish, powershell
EOF
`

	tmpl, err := template.New("sh").Parse(shTemplate)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, g)
	if err != nil {
		return "", err
	}

	return buf.String(), nil
}
