// ABOUTME: Workflow bridge provides access to go-llms workflow functionality for script engines
// ABOUTME: Wraps workflow creation, configuration, step management, and execution without reimplementation

package agent

import (
	"context"
	"fmt"
	"sync"

	"github.com/lexlapax/go-llmspell/pkg/bridge"
	"github.com/lexlapax/go-llmspell/pkg/engine"

	// go-llms imports for workflow functionality
	"github.com/lexlapax/go-llms/pkg/agent/domain"
	"github.com/lexlapax/go-llms/pkg/agent/workflow"
)

// WorkflowBridge provides script access to go-llms workflow functionality
type WorkflowBridge struct {
	mu          sync.RWMutex
	initialized bool
	workflows   map[string]bridge.BaseAgent // Workflows are agents in go-llms

	// Task 1.4.10.1: Workflow Import/Export
	serializers     map[string]workflow.WorkflowSerializer
	serializerCache map[string][]byte // Cache serialized workflows

	// Task 1.4.10.2: Script Step Handlers
	scriptHandlers map[string]ScriptStepHandler
	scriptRegistry map[string]*workflow.ScriptStep

	// Task 1.4.10.3: Workflow Templates
	templateCache    map[string]*workflow.WorkflowTemplate
	templateRegistry map[string]*workflow.WorkflowTemplate // Local template registry
}

// ScriptStepHandler handles script execution for workflow steps
type ScriptStepHandler struct {
	Language  string
	Validator func(script string) error
	Executor  func(ctx context.Context, script string, env map[string]interface{}) (interface{}, error)
	Debugger  func(script string, breakpoint int) error
	Metadata  map[string]interface{}
}

// NewWorkflowBridge creates a new workflow bridge
func NewWorkflowBridge() *WorkflowBridge {
	return &WorkflowBridge{
		workflows:        make(map[string]bridge.BaseAgent),
		serializers:      make(map[string]workflow.WorkflowSerializer),
		serializerCache:  make(map[string][]byte),
		scriptHandlers:   make(map[string]ScriptStepHandler),
		scriptRegistry:   make(map[string]*workflow.ScriptStep),
		templateCache:    make(map[string]*workflow.WorkflowTemplate),
		templateRegistry: make(map[string]*workflow.WorkflowTemplate),
	}
}

// GetID returns the bridge identifier
func (b *WorkflowBridge) GetID() string {
	return "workflow"
}

// GetMetadata returns bridge metadata
func (b *WorkflowBridge) GetMetadata() engine.BridgeMetadata {
	return engine.BridgeMetadata{
		Name:        "workflow",
		Version:     "2.0.0",
		Description: "Enhanced workflow engine bridge with serialization, script steps, and templates (v0.3.5)",
		Author:      "go-llmspell",
		License:     "MIT",
	}
}

// Initialize initializes the bridge
func (b *WorkflowBridge) Initialize(ctx context.Context) error {
	b.mu.Lock()
	defer b.mu.Unlock()

	if b.initialized {
		return nil
	}

	// Initialize default serializers
	b.serializers["json"] = workflow.NewJSONWorkflowSerializer(false)
	b.serializers["json-pretty"] = workflow.NewJSONWorkflowSerializer(true)
	b.serializers["yaml"] = workflow.NewYAMLWorkflowSerializer()

	// Initialize default script handlers
	b.initializeDefaultScriptHandlers()

	// Register default templates
	if err := workflow.RegisterDefaultTemplates(); err != nil {
		return fmt.Errorf("failed to register default templates: %w", err)
	}

	b.initialized = true
	return nil
}

// Cleanup cleans up bridge resources
func (b *WorkflowBridge) Cleanup(ctx context.Context) error {
	b.mu.Lock()
	defer b.mu.Unlock()

	// Clean up any registered workflows
	for id, workflow := range b.workflows {
		if err := workflow.Cleanup(ctx); err != nil {
			// Log error but continue cleanup
			_ = err
		}
		delete(b.workflows, id)
	}

	b.initialized = false
	return nil
}

// IsInitialized checks if the bridge is initialized
func (b *WorkflowBridge) IsInitialized() bool {
	b.mu.RLock()
	defer b.mu.RUnlock()
	return b.initialized
}

// RegisterWithEngine registers the bridge with a script engine
func (b *WorkflowBridge) RegisterWithEngine(engine engine.ScriptEngine) error {
	return engine.RegisterBridge(b)
}

// Methods returns the methods exposed by this bridge
func (b *WorkflowBridge) Methods() []engine.MethodInfo {
	return []engine.MethodInfo{
		// Workflow creation methods
		{
			Name:        "createSequentialWorkflow",
			Description: "Create a sequential workflow that executes steps one after another",
			Parameters: []engine.ParameterInfo{
				{Name: "name", Type: "string", Description: "Workflow name", Required: true},
				{Name: "config", Type: "object", Description: "Sequential workflow configuration", Required: true},
			},
			ReturnType: "WorkflowAgent",
		},
		{
			Name:        "createParallelWorkflow",
			Description: "Create a parallel workflow that executes steps concurrently",
			Parameters: []engine.ParameterInfo{
				{Name: "name", Type: "string", Description: "Workflow name", Required: true},
				{Name: "config", Type: "object", Description: "Parallel workflow configuration", Required: true},
			},
			ReturnType: "WorkflowAgent",
		},
		{
			Name:        "createConditionalWorkflow",
			Description: "Create a conditional workflow with branching logic",
			Parameters: []engine.ParameterInfo{
				{Name: "name", Type: "string", Description: "Workflow name", Required: true},
				{Name: "config", Type: "object", Description: "Conditional workflow configuration", Required: true},
			},
			ReturnType: "WorkflowAgent",
		},
		{
			Name:        "createLoopWorkflow",
			Description: "Create a loop workflow for iterative processing",
			Parameters: []engine.ParameterInfo{
				{Name: "name", Type: "string", Description: "Workflow name", Required: true},
				{Name: "config", Type: "object", Description: "Loop workflow configuration", Required: true},
			},
			ReturnType: "WorkflowAgent",
		},
		// Step management
		{
			Name:        "addWorkflowStep",
			Description: "Add a step to a workflow",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
				{Name: "step", Type: "object", Description: "Step configuration", Required: true},
			},
			ReturnType: "void",
		},
		{
			Name:        "removeWorkflowStep",
			Description: "Remove a step from a workflow",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
				{Name: "stepID", Type: "string", Description: "Step ID to remove", Required: true},
			},
			ReturnType: "void",
		},
		{
			Name:        "getWorkflowSteps",
			Description: "Get all steps in a workflow",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
			},
			ReturnType: "array",
		},
		{
			Name:        "updateWorkflowStep",
			Description: "Update a workflow step configuration",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
				{Name: "stepID", Type: "string", Description: "Step ID", Required: true},
				{Name: "config", Type: "object", Description: "Updated step configuration", Required: true},
			},
			ReturnType: "void",
		},
		{
			Name:        "reorderWorkflowSteps",
			Description: "Reorder steps in a sequential workflow",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
				{Name: "stepOrder", Type: "array", Description: "New step order (array of step IDs)", Required: true},
			},
			ReturnType: "void",
		},
		// Workflow configuration
		{
			Name:        "setWorkflowConfig",
			Description: "Update workflow configuration",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
				{Name: "config", Type: "object", Description: "Workflow configuration", Required: true},
			},
			ReturnType: "void",
		},
		{
			Name:        "getWorkflowConfig",
			Description: "Get workflow configuration",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
			},
			ReturnType: "object",
		},
		// Execution methods
		{
			Name:        "executeWorkflow",
			Description: "Execute a workflow synchronously",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
				{Name: "input", Type: "any", Description: "Workflow input", Required: false},
			},
			ReturnType: "any",
		},
		{
			Name:        "executeWorkflowAsync",
			Description: "Execute a workflow asynchronously",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
				{Name: "input", Type: "any", Description: "Workflow input", Required: false},
			},
			ReturnType: "channel",
		},
		// Workflow state and status
		{
			Name:        "getWorkflowStatus",
			Description: "Get the current status of a workflow",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
			},
			ReturnType: "WorkflowStatus",
		},
		{
			Name:        "getWorkflowState",
			Description: "Get the current state of a workflow",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
			},
			ReturnType: "WorkflowState",
		},
		{
			Name:        "setWorkflowState",
			Description: "Set the state of a workflow",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
				{Name: "state", Type: "WorkflowState", Description: "New workflow state", Required: true},
			},
			ReturnType: "void",
		},
		// Execution control
		{
			Name:        "pauseWorkflow",
			Description: "Pause a running workflow",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
			},
			ReturnType: "void",
		},
		{
			Name:        "resumeWorkflow",
			Description: "Resume a paused workflow",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
			},
			ReturnType: "void",
		},
		{
			Name:        "cancelWorkflow",
			Description: "Cancel a running workflow",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
			},
			ReturnType: "void",
		},
		{
			Name:        "retryWorkflowStep",
			Description: "Retry a failed workflow step",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
				{Name: "stepID", Type: "string", Description: "Step ID to retry", Required: true},
			},
			ReturnType: "void",
		},
		// Workflow management
		{
			Name:        "listWorkflows",
			Description: "List all registered workflows",
			Parameters:  []engine.ParameterInfo{},
			ReturnType:  "array",
		},
		{
			Name:        "getWorkflow",
			Description: "Get a workflow by ID",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
			},
			ReturnType: "WorkflowAgent",
		},
		{
			Name:        "removeWorkflow",
			Description: "Remove a workflow",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
			},
			ReturnType: "void",
		},
		// Error handling
		{
			Name:        "setWorkflowErrorHandler",
			Description: "Set error handler for a workflow",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
				{Name: "handler", Type: "function", Description: "Error handler function", Required: true},
			},
			ReturnType: "void",
		},
		// Hooks and events
		{
			Name:        "setWorkflowHook",
			Description: "Set a lifecycle hook for a workflow",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
				{Name: "hookType", Type: "string", Description: "Hook type (beforeStep, afterStep, etc.)", Required: true},
				{Name: "handler", Type: "function", Description: "Hook handler function", Required: true},
			},
			ReturnType: "void",
		},
		{
			Name:        "subscribeToWorkflowEvents",
			Description: "Subscribe to workflow events",
			Parameters: []engine.ParameterInfo{
				{Name: "workflowID", Type: "string", Description: "Workflow ID", Required: true},
				{Name: "eventType", Type: "string", Description: "Event type to subscribe to", Required: false},
				{Name: "handler", Type: "function", Description: "Event handler", Required: true},
			},
			ReturnType: "string", // subscription ID
		},
	}
}

// TypeMappings returns type conversion mappings
func (b *WorkflowBridge) TypeMappings() map[string]engine.TypeMapping {
	return map[string]engine.TypeMapping{
		"WorkflowAgent": {
			GoType:     "BaseAgent",
			ScriptType: "object",
		},
		"WorkflowStep": {
			GoType:     "WorkflowStep",
			ScriptType: "object",
		},
		"WorkflowState": {
			GoType:     "*WorkflowState",
			ScriptType: "object",
		},
		"WorkflowDefinition": {
			GoType:     "WorkflowDefinition",
			ScriptType: "object",
		},
		"WorkflowStatus": {
			GoType:     "WorkflowStatus",
			ScriptType: "object",
		},
		"WorkflowConfig": {
			GoType:     "WorkflowConfig",
			ScriptType: "object",
		},
		"SequentialConfig": {
			GoType:     "SequentialConfig",
			ScriptType: "object",
		},
		"ParallelConfig": {
			GoType:     "ParallelConfig",
			ScriptType: "object",
		},
		"ConditionalConfig": {
			GoType:     "ConditionalConfig",
			ScriptType: "object",
		},
		"LoopConfig": {
			GoType:     "LoopConfig",
			ScriptType: "object",
		},
		"ErrorHandler": {
			GoType:     "ErrorHandler",
			ScriptType: "function",
		},
		"StepResult": {
			GoType:     "StepResult",
			ScriptType: "object",
		},
		"ErrorAction": {
			GoType:     "ErrorAction",
			ScriptType: "string",
		},
		"BranchCondition": {
			GoType:     "BranchCondition",
			ScriptType: "object",
		},
		"LoopCondition": {
			GoType:     "LoopCondition",
			ScriptType: "object",
		},
	}
}

// ValidateMethod validates method calls
func (b *WorkflowBridge) ValidateMethod(name string, args []engine.ScriptValue) error {
	// Method validation handled by engine based on Methods() metadata
	return nil
}

// RequiredPermissions returns required permissions
func (b *WorkflowBridge) RequiredPermissions() []engine.Permission {
	return []engine.Permission{
		{
			Type:        engine.PermissionProcess,
			Resource:    "workflow",
			Actions:     []string{"create", "execute", "manage"},
			Description: "Access to workflow engine",
		},
		{
			Type:        engine.PermissionMemory,
			Resource:    "state",
			Actions:     []string{"allocate", "manage"},
			Description: "Memory for workflow state and execution",
		},
	}
}

// Helper methods for type conversion and workflow management

// getWorkflow retrieves a workflow by ID
//
//nolint:unused // will be used when implementing workflow methods
func (b *WorkflowBridge) getWorkflow(id string) (bridge.BaseAgent, error) {
	b.mu.RLock()
	defer b.mu.RUnlock()

	workflow, exists := b.workflows[id]
	if !exists {
		return nil, fmt.Errorf("workflow %s not found", id)
	}
	return workflow, nil
}

// registerWorkflow registers a workflow in the bridge
//
//nolint:unused // will be used when implementing workflow creation methods
func (b *WorkflowBridge) registerWorkflow(workflow bridge.BaseAgent) error {
	b.mu.Lock()
	defer b.mu.Unlock()

	if _, exists := b.workflows[workflow.ID()]; exists {
		return fmt.Errorf("workflow %s already registered", workflow.ID())
	}

	b.workflows[workflow.ID()] = workflow
	return nil
}

// initializeDefaultScriptHandlers sets up default script handlers
func (b *WorkflowBridge) initializeDefaultScriptHandlers() {
	// JavaScript handler
	b.scriptHandlers["javascript"] = ScriptStepHandler{
		Language: "javascript",
		Validator: func(script string) error {
			// Basic JavaScript validation
			if script == "" {
				return fmt.Errorf("empty script")
			}
			return nil
		},
		Executor: func(ctx context.Context, script string, env map[string]interface{}) (interface{}, error) {
			// Placeholder - would use actual JavaScript engine
			return map[string]interface{}{
				"result": "JavaScript execution placeholder",
				"script": script,
				"env":    env,
			}, nil
		},
		Metadata: map[string]interface{}{
			"supported": true,
			"version":   "ES6",
		},
	}

	// Lua handler
	b.scriptHandlers["lua"] = ScriptStepHandler{
		Language: "lua",
		Validator: func(script string) error {
			if script == "" {
				return fmt.Errorf("empty script")
			}
			return nil
		},
		Executor: func(ctx context.Context, script string, env map[string]interface{}) (interface{}, error) {
			// Placeholder - would use actual Lua engine
			return map[string]interface{}{
				"result": "Lua execution placeholder",
				"script": script,
				"env":    env,
			}, nil
		},
		Metadata: map[string]interface{}{
			"supported": true,
			"version":   "5.4",
		},
	}

	// Tengo handler
	b.scriptHandlers["tengo"] = ScriptStepHandler{
		Language: "tengo",
		Validator: func(script string) error {
			if script == "" {
				return fmt.Errorf("empty script")
			}
			return nil
		},
		Executor: func(ctx context.Context, script string, env map[string]interface{}) (interface{}, error) {
			// Placeholder - would use actual Tengo engine
			return map[string]interface{}{
				"result": "Tengo execution placeholder",
				"script": script,
				"env":    env,
			}, nil
		},
		Metadata: map[string]interface{}{
			"supported": true,
			"version":   "2.0",
		},
	}
}

// removeWorkflowInternal removes a workflow from the bridge
//
//nolint:unused // will be used when implementing removeWorkflow method
func (b *WorkflowBridge) removeWorkflowInternal(id string) error {
	b.mu.Lock()
	defer b.mu.Unlock()

	workflow, exists := b.workflows[id]
	if !exists {
		return fmt.Errorf("workflow %s not found", id)
	}

	// Cleanup the workflow
	if err := workflow.Cleanup(context.Background()); err != nil {
		return fmt.Errorf("failed to cleanup workflow %s: %w", id, err)
	}

	delete(b.workflows, id)
	return nil
}

// ExecuteMethod executes a bridge method by calling the appropriate go-llms function
func (b *WorkflowBridge) ExecuteMethod(ctx context.Context, name string, args []engine.ScriptValue) (engine.ScriptValue, error) {
	b.mu.RLock()
	defer b.mu.RUnlock()

	if !b.initialized {
		return nil, fmt.Errorf("bridge not initialized")
	}

	switch name {
	case "createSequentialWorkflow":
		if len(args) < 2 {
			return nil, fmt.Errorf("createSequentialWorkflow requires name and config parameters")
		}
		name, ok := args[0].(string)
		if !ok {
			return nil, fmt.Errorf("name must be string")
		}
		config, ok := args[1].(map[string]interface{})
		if !ok {
			return nil, fmt.Errorf("config must be object")
		}

		// Placeholder until go-llms workflow package is available
		// Will create actual workflow using workflow.NewSequentialWorkflow
		return map[string]interface{}{
			"id":     fmt.Sprintf("workflow-%s", name),
			"type":   "sequential",
			"name":   name,
			"config": config,
		}, nil

	case "listWorkflows":
		workflows := make([]map[string]interface{}, 0, len(b.workflows))
		for id, workflow := range b.workflows {
			workflows = append(workflows, map[string]interface{}{
				"id":   id,
				"type": workflow.Type(),
				"name": workflow.Name(),
			})
		}
		return workflows, nil

	case "executeWorkflow":
		if len(args) < 1 {
			return nil, fmt.Errorf("executeWorkflow requires workflowID parameter")
		}
		workflowID, ok := args[0].(string)
		if !ok {
			return nil, fmt.Errorf("workflowID must be string")
		}

		workflow, err := b.getWorkflow(workflowID)
		if err != nil {
			return nil, err
		}

		// Create input state
		inputState := domain.NewState()
		if len(args) > 1 && args[1] != nil {
			if inputData, ok := args[1].(map[string]interface{}); ok {
				for k, v := range inputData {
					inputState.Set(k, v)
				}
			}
		}

		// Execute workflow
		resultState, err := workflow.Run(ctx, inputState)
		if err != nil {
			return nil, fmt.Errorf("workflow execution failed: %w", err)
		}

		// Return result state values
		return resultState.Values(), nil

	// Task 1.4.10.1: Workflow Import/Export
	case "exportWorkflow":
		if len(args) < 1 {
			return nil, fmt.Errorf("exportWorkflow requires workflowID parameter")
		}
		workflowID, ok := args[0].(string)
		if !ok {
			return nil, fmt.Errorf("workflowID must be string")
		}

		format := "json"
		if len(args) > 1 && args[1] != nil {
			if f, ok := args[1].(string); ok {
				format = f
			}
		}

		// Check cache first
		cacheKey := fmt.Sprintf("%s:%s", workflowID, format)
		if cached, exists := b.serializerCache[cacheKey]; exists {
			return string(cached), nil
		}

		// Get workflow and serialize
		wf, err := b.getWorkflow(workflowID)
		if err != nil {
			return nil, err
		}

		// Create workflow definition from agent
		def := &workflow.WorkflowDefinition{
			Name:        wf.Name(),
			Description: wf.Description(),
			Steps:       []workflow.WorkflowStep{},
		}

		serializer := b.serializers[format]
		if serializer == nil {
			return nil, fmt.Errorf("unsupported format: %s", format)
		}

		data, err := serializer.Serialize(def)
		if err != nil {
			return nil, fmt.Errorf("serialization failed: %w", err)
		}

		// Cache the result
		b.serializerCache[cacheKey] = data

		return string(data), nil

	case "importWorkflow":
		if len(args) < 1 {
			return nil, fmt.Errorf("importWorkflow requires data parameter")
		}
		data, ok := args[0].(string)
		if !ok {
			return nil, fmt.Errorf("data must be string")
		}

		format := "json"
		if len(args) > 1 && args[1] != nil {
			if f, ok := args[1].(string); ok {
				format = f
			}
		}

		serializer := b.serializers[format]
		if serializer == nil {
			return nil, fmt.Errorf("unsupported format: %s", format)
		}

		def, err := serializer.Deserialize([]byte(data))
		if err != nil {
			return nil, fmt.Errorf("deserialization failed: %w", err)
		}

		// Create workflow from definition
		return map[string]interface{}{
			"id":          fmt.Sprintf("workflow-%s", def.Name),
			"name":        def.Name,
			"description": def.Description,
			"steps":       len(def.Steps),
		}, nil

	case "validateWorkflowData":
		if len(args) < 1 {
			return nil, fmt.Errorf("validateWorkflowData requires data parameter")
		}
		data, ok := args[0].(string)
		if !ok {
			return nil, fmt.Errorf("data must be string")
		}

		format := "json"
		if len(args) > 1 && args[1] != nil {
			if f, ok := args[1].(string); ok {
				format = f
			}
		}

		serializer := b.serializers[format]
		if serializer == nil {
			return nil, fmt.Errorf("unsupported format: %s", format)
		}

		_, err := serializer.Deserialize([]byte(data))
		if err != nil {
			return map[string]interface{}{
				"valid":  false,
				"error":  err.Error(),
				"format": format,
			}, nil
		}

		return map[string]interface{}{
			"valid":  true,
			"format": format,
		}, nil

	// Task 1.4.10.2: Script Step Handlers
	case "registerScriptHandler":
		if len(args) < 2 {
			return nil, fmt.Errorf("registerScriptHandler requires language and handler parameters")
		}
		language, ok := args[0].(string)
		if !ok {
			return nil, fmt.Errorf("language must be string")
		}
		handlerConfig, ok := args[1].(map[string]interface{})
		if !ok {
			return nil, fmt.Errorf("handler must be object")
		}

		// Create handler from config
		handler := ScriptStepHandler{
			Language: language,
			Metadata: handlerConfig,
		}

		b.scriptHandlers[language] = handler
		return nil, nil

	case "createScriptStep":
		if len(args) < 3 {
			return nil, fmt.Errorf("createScriptStep requires name, language, and script parameters")
		}
		name, ok := args[0].(string)
		if !ok {
			return nil, fmt.Errorf("name must be string")
		}
		language, ok := args[1].(string)
		if !ok {
			return nil, fmt.Errorf("language must be string")
		}
		script, ok := args[2].(string)
		if !ok {
			return nil, fmt.Errorf("script must be string")
		}

		// Check if handler exists in our bridge
		if _, exists := b.scriptHandlers[language]; !exists {
			return nil, fmt.Errorf("no handler for language: %s", language)
		}

		// Create script step metadata (since we can't use workflow.ScriptStep directly)
		stepID := fmt.Sprintf("script-%s-%s", language, name)

		// Store step configuration for later use
		stepConfig := map[string]interface{}{
			"id":       stepID,
			"name":     name,
			"language": language,
			"script":   script,
			"type":     "script",
		}

		if len(args) > 3 && args[3] != nil {
			if config, ok := args[3].(map[string]interface{}); ok {
				if desc, ok := config["description"].(string); ok {
					stepConfig["description"] = desc
				}
				if env, ok := config["environment"].(map[string]interface{}); ok {
					stepConfig["environment"] = env
				}
			}
		}

		return stepConfig, nil

	case "validateScriptStep":
		if len(args) < 1 {
			return nil, fmt.Errorf("validateScriptStep requires step parameter")
		}
		stepData, ok := args[0].(map[string]interface{})
		if !ok {
			return nil, fmt.Errorf("step must be object")
		}

		language, _ := stepData["language"].(string)
		script, _ := stepData["script"].(string)

		handler, exists := b.scriptHandlers[language]
		if !exists {
			return map[string]interface{}{
				"valid": false,
				"error": fmt.Sprintf("no handler for language: %s", language),
			}, nil
		}

		if handler.Validator != nil {
			if err := handler.Validator(script); err != nil {
				return map[string]interface{}{
					"valid": false,
					"error": err.Error(),
				}, nil
			}
		}

		return map[string]interface{}{
			"valid":    true,
			"language": language,
		}, nil

	// Task 1.4.10.3: Workflow Templates
	case "listTemplates":
		var templates []*workflow.WorkflowTemplate

		if len(args) > 0 && args[0] != nil {
			if category, ok := args[0].(string); ok {
				templates = workflow.ListTemplatesByCategory(category)
			}
		} else if len(args) > 1 && args[1] != nil {
			if tags, ok := args[1].([]string); ok {
				templates = workflow.SearchTemplates(tags)
			}
		} else {
			templates = workflow.ListTemplates()
		}

		// Include local templates
		for _, tmpl := range b.templateRegistry {
			templates = append(templates, tmpl)
		}

		result := make([]map[string]interface{}, len(templates))
		for i, tmpl := range templates {
			result[i] = map[string]interface{}{
				"id":          tmpl.ID,
				"name":        tmpl.Name,
				"description": tmpl.Description,
				"category":    tmpl.Category,
				"tags":        tmpl.Tags,
			}
		}

		return result, nil

	case "getTemplate":
		if len(args) < 1 {
			return nil, fmt.Errorf("getTemplate requires templateID parameter")
		}
		templateID, ok := args[0].(string)
		if !ok {
			return nil, fmt.Errorf("templateID must be string")
		}

		// Check local registry first
		if tmpl, exists := b.templateRegistry[templateID]; exists {
			return tmpl, nil
		}

		// Check global registry
		tmpl, err := workflow.GetTemplate(templateID)
		if err != nil {
			return nil, err
		}

		return tmpl, nil

	case "createFromTemplate":
		if len(args) < 1 {
			return nil, fmt.Errorf("createFromTemplate requires templateID parameter")
		}
		templateID, ok := args[0].(string)
		if !ok {
			return nil, fmt.Errorf("templateID must be string")
		}

		variables := make(map[string]interface{})
		if len(args) > 1 && args[1] != nil {
			if vars, ok := args[1].(map[string]interface{}); ok {
				variables = vars
			}
		}

		def, err := workflow.ApplyTemplate(templateID, variables)
		if err != nil {
			return nil, fmt.Errorf("failed to apply template: %w", err)
		}

		return map[string]interface{}{
			"id":           fmt.Sprintf("workflow-%s", def.Name),
			"name":         def.Name,
			"description":  def.Description,
			"fromTemplate": templateID,
		}, nil

	case "registerTemplate":
		if len(args) < 1 {
			return nil, fmt.Errorf("registerTemplate requires template parameter")
		}
		templateData, ok := args[0].(map[string]interface{})
		if !ok {
			return nil, fmt.Errorf("template must be object")
		}

		// Create template from data
		tmpl := &workflow.WorkflowTemplate{
			ID:          templateData["id"].(string),
			Name:        templateData["name"].(string),
			Description: templateData["description"].(string),
		}

		if category, ok := templateData["category"].(string); ok {
			tmpl.Category = category
		}
		if tags, ok := templateData["tags"].([]string); ok {
			tmpl.Tags = tags
		}

		// Store in local registry
		b.templateRegistry[tmpl.ID] = tmpl

		return tmpl.ID, nil

	default:
		return nil, fmt.Errorf("method not found: %s", name)
	}
}
